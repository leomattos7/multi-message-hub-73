
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing environment variables for Supabase');
}

// Create Supabase client
export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey);

// Add custom functions to extend Supabase client functionality
// These are useful for app-specific operations

/**
 * Create a patient
 */
export const createPatient = async (patientData: {
  name: string;
  email?: string;
  phone?: string;
  birth_date?: string;
  gender?: string;
  address?: string;
  notes?: string;
}) => {
  const { data, error } = await supabase
    .from('patients')
    .insert(patientData)
    .select()
    .single();

  if (error) throw error;
  return data;
};

/**
 * Update a patient
 */
export const updatePatient = async (
  patientId: string,
  patientData: {
    name?: string;
    email?: string;
    phone?: string;
    birth_date?: string;
    gender?: string;
    address?: string;
    notes?: string;
  }
) => {
  const { data, error } = await supabase
    .from('patients')
    .update(patientData)
    .eq('id', patientId)
    .select()
    .single();

  if (error) throw error;
  return data;
};

/**
 * Delete a patient
 */
export const deletePatient = async (patientId: string) => {
  const { error } = await supabase
    .from('patients')
    .delete()
    .eq('id', patientId);

  if (error) throw error;
  return true;
};

/**
 * Create a medical record
 */
export const createMedicalRecord = async (recordData: {
  patient_id: string;
  record_date: string;
  record_type: string;
  content: string;
}) => {
  const { data, error } = await supabase
    .from('patient_records')
    .insert(recordData)
    .select()
    .single();

  if (error) throw error;
  return data;
};

/**
 * Update a medical record
 */
export const updateMedicalRecord = async (
  recordId: string,
  recordData: {
    record_date?: string;
    record_type?: string;
    content?: string;
  }
) => {
  const { data, error } = await supabase
    .from('patient_records')
    .update(recordData)
    .eq('id', recordId)
    .select()
    .single();

  if (error) throw error;
  return data;
};

/**
 * Delete a medical record
 */
export const deleteMedicalRecord = async (recordId: string) => {
  const { error } = await supabase
    .from('patient_records')
    .delete()
    .eq('id', recordId);

  if (error) throw error;
  return true;
};

/**
 * Create an appointment
 */
export const createAppointment = async (appointmentData: {
  patient_id: string;
  date: string;
  time: string;
  type: string;
  status: string;
  payment_method?: string;
  notes?: string;
}) => {
  const { data, error } = await supabase
    .from('appointments')
    .insert(appointmentData)
    .select()
    .single();

  if (error) throw error;
  return data;
};

/**
 * Update an appointment
 */
export const updateAppointment = async (
  appointmentId: string,
  appointmentData: {
    patient_id?: string;
    date?: string;
    time?: string;
    type?: string;
    status?: string;
    payment_method?: string;
    notes?: string;
  }
) => {
  const { data, error } = await supabase
    .from('appointments')
    .update(appointmentData)
    .eq('id', appointmentId)
    .select()
    .single();

  if (error) throw error;
  return data;
};

/**
 * Delete an appointment
 */
export const deleteAppointment = async (appointmentId: string) => {
  const { error } = await supabase
    .from('appointments')
    .delete()
    .eq('id', appointmentId);

  if (error) throw error;
  return true;
};

/**
 * Get doctor profile by public URL slug
 */
export const getDoctorProfileBySlug = async (slug: string) => {
  const { data, error } = await supabase
    .from('doctor_profiles')
    .select(`*`)
    .eq('public_url_slug', slug)
    .single();

  if (error) throw error;
  
  // If data exists, fetch associated links
  if (data) {
    const { data: linksData, error: linksError } = await supabase
      .from('doctor_links')
      .select('*')
      .eq('doctor_id', data.id);
    
    if (linksError) throw linksError;
    
    // Use type assertion to fix the type issue
    return {
      ...data,
      doctor_links: linksData || []
    } as any; // Use type assertion to handle the doctor_links property
  }
  
  return data;
};

// Mock service for tags to fix missing exports
export const tagService = {
  getTags: async () => {
    // Return mock tags data
    return [
      { id: '1', name: 'Urgente', color: '#F87171' },
      { id: '2', name: 'Consulta', color: '#60A5FA' },
      { id: '3', name: 'Retorno', color: '#34D399' },
      { id: '4', name: 'Exames', color: '#FBBF24' }
    ];
  },
  createTag: async (name: string, color: string) => {
    return { id: 'new-tag', name, color };
  },
  updateTag: async (id: string, updates: { name: string; color: string }) => {
    return { id, ...updates };
  },
  deleteTag: async (id: string) => {
    return true;
  },
  assignTagToConversation: async (conversationId: string, tagId: string) => {
    return { id: 'relation-id', conversation_id: conversationId, tag_id: tagId };
  },
  removeTagFromConversation: async (conversationId: string, tagId: string) => {
    return true;
  }
};

// Mock service for conversations
export const conversationService = {
  getConversations: async () => {
    // Return mock conversation data
    return [
      {
        id: '1',
        channel: 'whatsapp',
        unread: 3,
        last_activity: new Date().toISOString(),
        patient: { id: '1', name: 'João Silva', email: 'joao@example.com' },
        messages: [{ content: 'Olá, como posso ajudar?', timestamp: new Date() }],
        tags: [{ id: '1', name: 'Urgente', color: '#F87171' }],
        is_archived: false
      }
    ];
  },
  getConversation: async (id: string) => {
    return {
      id,
      channel: 'whatsapp',
      unread: 0,
      last_activity: new Date().toISOString(),
      patient: { id: '1', name: 'João Silva', email: 'joao@example.com' },
      messages: [
        { id: '1', content: 'Olá, como posso agendar uma consulta?', timestamp: new Date(), isOutgoing: false },
        { id: '2', content: 'Bom dia! Posso ajudar com isso. Que data você prefere?', timestamp: new Date(), isOutgoing: true }
      ],
      tags: [{ id: '1', name: 'Urgente', color: '#F87171' }]
    };
  },
  sendMessage: async (conversationId: string, content: string) => {
    return {
      id: `new-${Date.now()}`,
      conversationId,
      content,
      timestamp: new Date(),
      isOutgoing: true,
      status: 'sent'
    };
  }
};

// Mock service for doctor profiles
export const doctorProfileService = {
  getDoctorProfile: async (doctorId: string) => {
    return {
      id: doctorId,
      name: 'Dr. Example',
      specialty: 'Cardiologia',
      bio: 'Médico especialista com 10 anos de experiência',
      public_url_slug: 'dr-example',
      doctor_links: []
    };
  },
  updateDoctorProfile: async (doctorId: string, data: any) => {
    return {
      id: doctorId,
      ...data,
      updated_at: new Date().toISOString()
    };
  }
};

// Create a time block for a doctor's schedule
export const createTimeBlock = async (blockData: any) => {
  // Mock implementation that returns the data without actually interacting with the database
  return {
    id: `mock-block-${Date.now()}`,
    ...blockData,
    created_at: new Date().toISOString()
  };
};

// Update a time block
export const updateTimeBlock = async (blockId: string, blockData: any) => {
  // Mock implementation that returns the updated data without database interaction
  return {
    id: blockId,
    ...blockData,
    updated_at: new Date().toISOString()
  };
};

// Delete a time block
export const deleteTimeBlock = async (blockId: string) => {
  // Mock implementation that always returns success
  return true;
};
